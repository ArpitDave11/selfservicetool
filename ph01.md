# **PHASE 1: REFACTOR TO TEMPLATE-DRIVEN UI**

### **OBJECTIVES**
1. Replace hardcoded `STAGES`/`EPIC_SECTIONS` with `TemplateRegistry`
2. Create React context for template state management
3. Build dynamic components that render purely from template data
4. Add GitLab epic selector UI
5. Implement template switching interface

---

## **STEP 1.1: Create Template React Context**

```bash
# Create context for template state
claude "Create src/templates/TemplateContext.tsx:

1. Interface: TemplateContextType
   - activeTemplate: EpicTemplate | null
   - registry: TemplateRegistry
   - isLoading: boolean
   - switchTemplate: (id: string) => void
   - importFromGitLab: (groupId: string, epicIid: number) => Promise<void>

2. Create context: const TemplateContext = createContext<TemplateContextType>(...)

3. Hook: export const useTemplate = () => useContext(TemplateContext)

4. Provider: TemplateProvider component
   - Manages activeTemplate state
   - Initializes registry
   - Handles template switching
   - Provides value to context consumers

5. Wrap App.tsx with TemplateProvider in main.tsx

Include TypeScript generics and error boundaries."
```

---

## **STEP 1.2: Create Dynamic Wizard Component**

```bash
# Extract wizard logic from App.tsx into dynamic component
claude "Create src/components/dynamic/DynamicWizard.tsx:

1. Component: DynamicWizard
   - Props: { className?: string }

2. Use useTemplate() to get activeTemplate
   - If no template, show 'Loading templates...'

3. State:
   - currentStageIndex: number
   - stageData: Record<string, RefinedData>
   - formData: Record<string, string>
   - loadingSuggestion: Record<string, boolean>

4. Render:
   - DynamicProgressIndicator (from template.stages)
   - Current stage fields (from template.stages[currentStageIndex].fields)
   - Navigation buttons (Next/Previous/Generate)

5. Methods:
   - handleFieldChange(fieldId, value)
   - handleRefine(fieldId, mode)
   - handleNextStage()
   - handlePrevStage()
   - handleGenerateEpic()

6. Use useCallback for all handlers

7. Preserve all existing UI styles (UBS branding, glass morphism)

This replaces the hardcoded wizard in App.tsx."
```

---

## **STEP 1.3: Create Dynamic Progress Indicator**

```bash
# Create progress component that renders from template
claude "Create src/components/dynamic/DynamicProgress.tsx:

1. Component: DynamicProgressIndicator
   - Props: { 
       stages: TemplateStage[], 
       currentIndex: number,
       onStageClick?: (index: number) => void 
     }

2. Render:
   - Map stages to progress dots
   - Map 'epic' as final step
   - Show stage labels below dots
   - Highlight active/completed stages

3. Styles:
   - Same as existing progress (red/black gradients)
   - Active: Red pulse animation
   - Completed: Black checkmark

4. Make clickable if onStageClick provided (for navigation)

5. Responsive: Wrap on mobile

Include Storybook-style comment with usage example."
```

---

## **STEP 1.4: Create Dynamic Stage Renderer**

```bash
# Create component to render any stage from template
claude "Create src/components/dynamic/StageRenderer.tsx:

1. Component: StageRenderer
   - Props: { 
       stage: TemplateStage,
       formData: Record<string, string>,
       stageData: Record<string, RefinedData>,
       onFieldChange: (fieldId, value) => void,
       onRefine: (fieldId, mode) => void,
       loadingSuggestion: Record<string, boolean>
     }

2. Render:
   - Stage title: 'Stage {index + 1}: {stage.title}'
   - Stage description: {stage.description}
   - Help banner (same as existing)

3. For each field:
   - Label with required indicator
   - Dual-mode buttons (Refine/Auto)
   - Input (text/textarea)
   - Loading shimmer
   - Alternative suggestions
   - Refined content (if available)
   - Edit button

4. Use template field definitions for:
   - placeholder
   - type
   - required validation

5. Maintain all existing styles and animations

Make it a pure component - no business logic, just rendering."
```

---

## **STEP 1.5: Create Dynamic Field Renderer**

```bash
# Create lowest-level field component
claude "Create src/components/dynamic/FieldRenderer.tsx:

1. Component: DynamicField
   - Props: {
       field: TemplateField,
       value: string,
       refinedValue?: string,
       isLoading: boolean,
       alternatives?: string[],
       onChange: (value) => void,
       onRefine: (mode: 'with-context' | 'auto') => void,
       onUseAlternative: (value) => void,
       onEditRefined: (value) => void
     }

2. Handles:
   - Text input vs textarea
   - Typewriter effect
   - Suggestion buttons
   - Alternative chips
   - Refined section (editable)
   - All styles and transitions

3. Pure rendering component

4. Use forwardRef if needed for focusing

This will be used by StageRenderer."
```

---

## **STEP 1.6: Refactor App.tsx to Use Template Context**

```bash
# Massive refactoring of main App.tsx
claude "Refactor src/App.tsx:

1. REMOVE all hardcoded references:
   - Remove import { STAGES, EPIC_SECTIONS } from './types'
   - Remove currentStage logic based on STAGES array
   - Remove populatedSections calculation based on EPIC_SECTIONS

2. ADD template context:
   - Import { useTemplate } from './templates/TemplateContext'
   - Import DynamicWizard from './components/dynamic/DynamicWizard'
   - Remove local wizard rendering logic

3. Simplify App.tsx structure:
   - Header (keep)
   - Progress indicator (replace with DynamicProgress)
   - DynamicWizard component (replaces renderWizard)
   - Keep epic editor, blueprint, settings
   - Remove all wizard state management (moved to DynamicWizard)

4. Keep only:
   - Config state (Azure, GitLab)
   - Toast system
   - Chat system
   - Blueprint state
   - Epic editor state

5. Template management UI:
   - Add template selector dropdown in header
   - Show active template name
   - Add 'Manage Templates' button

Result: App.tsx goes from 1500+ lines to ~800 lines
Wizard logic completely extracted to dynamic components."
```

---

## **STEP 1.7: Add GitLab Epic Selector UI**

```bash
# Create UI for selecting epics from GitLab
claude "Create src/components/gitlab/EpicSelector.tsx:

1. Component: GitLabEpicSelector
   - Props: { onEpicSelect: (epic: GitLabEpic) => void }

2. State:
   - rootGroupId: string (from VITE_GITLAB_ROOT_GROUP_ID)
   - loading: boolean
   - epics: GitLabEpic[]
   - error: string | null

3. Use GitLabApiClient:
   - Initialize with token from env
   - Call fetchEpicsRecursively in useEffect

4. Render:
   - Loading state (skeleton)
   - Error state
   - Tree view of groups/subgroups with epics
   - Each epic clickable to select

5. Style: Match UBS branding

Include 'Import as Template' button for template epics."
```

---

## **STEP 1.8: Add Template Management UI**

```bash
# Create template management panel
claude "Create src/components/template/TemplateManager.tsx:

1. Component: TemplateManager
   - Shows list of registered templates
   - Shows which are from GitLab
   - Shows active status

2. Features:
   - Import new template (JSON upload)
   - Fetch from GitLab (opens EpicSelector)
   - Export template (JSON download)
   - Activate template (switchTemplate)
   - Delete template (if not active)

3. Integration:
   - Use useTemplate() for state
   - Use TemplateRegistry for operations

4. Modal or slide-out panel

Include search/filter functionality."
```

---

## **STEP 1.9: Update Type Definitions**

```bash
# Update types.ts to remove hardcoded constants
claude "Modify src/types/types.ts:

1. KEEP the interfaces (Stage, StageField, EpicSection) but:
   - Rename to LegacyStage, LegacyEpicSection to avoid conflicts
   - Add @deprecated JSDoc

2. ADD comment:
   // @deprecated - Use EpicTemplate from templates/schemas/template.types.ts
   // These are kept for backward compatibility during migration

3. DO NOT remove STAGES and EPIC_SECTIONS yet (will be removed in Phase 2)

4. Add export statement:
   export { EpicTemplate, TemplateStage, TemplateField } from '../templates/schemas/template.types'

This prepares for removal while maintaining compatibility."
```

---

## **STEP 1.10: Update Main Entry Point**

```bash
# Wrap app with TemplateProvider
claude "Modify src/main.tsx:

import { TemplateProvider } from './templates/TemplateContext';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <TemplateProvider>
      <App />
    </TemplateProvider>
  </StrictMode>
);

Add error boundary:
<ErrorBoundary fallback={<div>Template system error</div>}>
  <TemplateProvider>
    <App />
  </TemplateProvider>
</ErrorBoundary>"
```

---

## **STEP 1.11: Create Integration Tests**

```bash
# Test template-driven rendering
claude "Create src/__tests__/phase1-integration.test.tsx:

Test suites:

1. 'TemplateContext'
   - Provides active template to consumers
   - Handles template switching
   - Imports from GitLab correctly

2. 'DynamicWizard'
   - Renders stages from active template
   - Navigates between stages
   - Calls onComplete with stage data

3. 'DynamicProgress'
   - Shows all stages from template
   - Highlights current stage
   - Shows epic as final step

4. 'StageRenderer'
   - Renders all fields for a stage
   - Calls onFieldChange on input
   - Shows refined content when available

5. 'EpicSelector'
   - Fetches epics recursively
   - Calls onEpicSelect when clicked
   - Handles errors gracefully

Use @testing-library/react and mock TemplateRegistry."
```

---

## **STEP 1.12: Commit Phase 1**

```bash
# Commit the massive refactoring
claude "Execute:
git add -A
git commit -m 'feat: Phase 1 - Template-Driven UI Refactor

Migrate from hardcoded STAGES to dynamic template system:

- React context for template state (TemplateContext)
- DynamicWizard component replacing inline wizard logic
- DynamicProgress, StageRenderer, FieldRenderer components
- Refactored App.tsx (reduced from 1500 to ~800 lines)
- GitLab EpicSelector UI component
- TemplateManager for template CRUD operations
- All UI now renders from active EpicTemplate
- Preserves UBS branding and styling

BREAKING CHANGE: App.tsx structure changed - all wizard logic moved
Closes: phase1-refactor'
"
```

---

## **PHASE 1 DELIVERABLES**

✅ **Template React Context**: Global template state  
✅ **Dynamic Wizard**: Renders from any template  
✅ **Dynamic Components**: Progress, Stage, Field renderers  
✅ **Refactored App.tsx**: Clean, template-agnostic  
✅ **GitLab Epic Selector**: UI for fetching epics  
✅ **Template Manager**: CRUD interface  
✅ **Tests**: Integration tests for all new components  
✅ **Backward Compatible**: Legacy template still works  

---

## **KEY CHANGES IN APP.TSX**

**Before (Phase 0):**
```typescript
// Hardcoded
const currentStage = STAGES[state.currentStage];
const populatedSections = getPopulatedSections(); // Uses EPIC_SECTIONS
```

**After (Phase 1):**
```typescript
// Dynamic
const { activeTemplate } = useTemplate();
const currentStage = activeTemplate.stages[state.currentStage];
const populatedSections = getPopulatedSections(activeTemplate); // Uses template
```

---

## **READY FOR PHASE 2?**

**Phase 2** will focus on:
1. **Parameterizing AI Skills**: Move all prompts from `skills.ts` into templates
2. **Dynamic Diagram Generation**: Connect diagram system to templates
3. **Critique Agent Integration**: Validate templates and generated content
4. **Remove Legacy Constants**: Delete hardcoded STAGES/EPIC_SECTIONS

Would you like me to proceed with **Phase 2** implementation?
